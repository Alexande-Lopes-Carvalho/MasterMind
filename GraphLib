#load "graphics.cma";;
#load "unix.cma";;
type ocImage = {image : Graphics.image; width : int; height : int};;

module Graph :
  sig
    val pxIN : int
    val width : int
    val height : int
    val frameRate : float
    val millis : unit -> float

    val wait : float -> unit

    val setup : unit -> unit

    val nameWindow : string

    val frameCount : int ref
    val mouseX : int ref
    val mouseY : int ref
    val startFrame : float ref
    val mousePos : bool ref
    val mousePressed : bool ref
    val mouseReleased : bool ref

    val beginDraw : unit -> unit
    val endDraw : unit -> unit
    val draw : (unit -> int) list -> int -> unit

    val mouseProc : unit -> unit

    val size : int -> int -> unit

    val exit : unit -> unit

    val color : int -> int -> int -> Graphics.color

    val fill : Graphics.color -> unit

    val rect : int -> int -> int -> int -> unit

    val background : Graphics.color -> unit

    val ellipse : int -> int -> int -> int -> unit

    val set : int -> int -> unit

    val line : int -> int -> int -> int -> unit

    val strokeWeight : int -> unit

    val text : string -> int -> int -> unit

    val wait : float -> unit

    val getImage : string -> Graphics.color array array

    val loadImage : string -> ocImage

    val loadImagePx : string -> ocImage

    val image : ocImage -> int -> int -> unit

  end =
  struct

    let pxIN = 4;;
    let width = pxIN*200;;
    let height = pxIN*150;;
    let nameWindow = "MasterMind";;
    let frameRate = 60.;; (* fps *)

    let startMillisCount = Unix.gettimeofday();;
    let millis () = (Unix.gettimeofday()-.startMillisCount)*.1000.;;width
    let waitValue = 1000./.frameRate;;

    let frameCount = ref 0;;
    let mouseX = ref 0;;
    let mouseY = ref 0;;
    let startFrame = ref 0.;;
    let mousePos = ref false;;
    let mousePressed = ref false;;
    let mouseReleased = ref false;;

    let rec wait start =
      (*print_endline ((string_of_float (Unix.gettimeofday())) ^ " " ^ string_of_float(start));*)
      if millis()-.start < waitValue then wait start
    ;;

    let mouseProc () =
      let bool = ref false in
      if Graphics.button_down () <> !mousePos then
        bool := true;
      if !bool then mousePos := not (!mousePos);
      mousePressed := (!bool && !mousePos);
      mouseReleased := (!bool && not(!mousePos))
    ;;

    let beginDraw () =
      let mouseCoord = Graphics.mouse_pos () in
      mouseX := fst (mouseCoord);
      mouseY := snd (mouseCoord);
      frameCount := !frameCount+1;
      mouseProc ();
      startFrame := millis()
    ;;

    let endDraw () =
      Graphics.synchronize ();
      wait (!startFrame);
    ;;

    let exit () = Graphics.close_graph ();;

    let rec draw proc choosed =
      beginDraw();
      let i = (List.nth proc choosed) () in
      endDraw();
      if i >= 0 then draw proc i
      else exit()
    ;;

    let size x y =
      Graphics.open_graph (" " ^ (string_of_int x)^"x"^(string_of_int y));
      Graphics.set_window_title nameWindow;
      Graphics.set_font "-*-fixed-medium-r-semicondensed--25-*-*-*-*-*-iso8859-1";
    ;;

    let setup () =
      size width height;
      Graphics.auto_synchronize false;
    ;;

    let color r g b = Graphics.rgb r g b;;

    let fill co = Graphics.set_color (co);;

    let rect x y w h =
      Graphics.fill_rect x y w h
    ;;

    let background co =
      fill co;
      rect 0 0 width height
    ;;

    let ellipse x y w h =
      Graphics.fill_ellipse x y (w/2) (h/2)
    ;;

    let set x y =
      Graphics.plot x y
    ;;

    let line x1 y1 x2 y2 =
      Graphics.moveto x1 y1;
      Graphics.lineto x2 y2;
    ;;

    let strokeWeight x = Graphics.set_line_width x;;

    let text txt x y =
      Graphics.moveto x y;
      Graphics.draw_string txt;
    ;;

    let input_line_option ch =
      try Some(input_line ch) with
      | _ -> None
    ;;

    let rec lireImagelignes_rec ch l =
      let k = input_line_option ch in
      match k with
      | Some(s) -> lireImagelignes_rec ch (l ^ s)
      | None -> close_in ch; l
    ;;

    let lireImagelignes data =
      lireImagelignes_rec data ""
    ;;

    let rec charlist_of_string_rec s i l =
      if i >= 0 then charlist_of_string_rec s (i-1) (String.get s i::l)
      else l
    ;;

    let charlist_of_string s =
      charlist_of_string_rec s ((String.length s)-1) []
    ;;

    let getImageWidthHeight x =
      let out = fst (List.fold_left (fun acc c -> let data = fst acc in
                                            let mode = snd acc in
                                            if mode then
                                              let out = (String.make 1 c) in (((fst data), (snd data) ^ out), mode)
                                            else
                                              let out = (String.make 1 c) in
                                              if String.compare out "|" = 0 then (data, true)
                                              else (((fst data)^out, snd data), mode)
                                    ) (("",""), false) (charlist_of_string x)) in (int_of_string (fst out), int_of_string (snd out))
    ;;

    let stringArrayInt a =
      (Array.fold_left (fun acc c -> acc ^ (string_of_int c)^" ") "[|" a) ^ "|]"
    ;;

    let stringArrayArrayInt a =
      (Array.fold_left (fun acc c -> acc ^ (stringArrayInt c)^ "\n ") "[|" a) ^ "|]"
    ;;

    let rec makeImage s i a =
      (*print_endline (string_of_int i);*)
      if i = Array.length (a)*Array.length (Array.get a 0) then a
      else
        match s with
        | alpha::r::g::b::l -> (*print_endline ((string_of_int i) ^ " " ^ string_of_int(int_of_char r) ^ " " ^ string_of_int(int_of_char g) ^ " " ^ string_of_int(int_of_char b) ^ " " ^ string_of_int(int_of_char alpha))(* ^ " \n" ^ (stringArrayArrayInt a))*);*)
                        Array.set (Array.get a (i/(Array.length (Array.get a 0)))) (i mod (Array.length (Array.get a 0))) (if (int_of_char alpha <> 0) then (Graphics.rgb (int_of_char r) (int_of_char g) (int_of_char b))
                                                                                                                           else Graphics.transp);
                        makeImage l (i+1) a
        | _ -> (*print_endline (stringArrayArrayInt a );*) a
    ;;

    let getImage path =
      let data = open_in (path) in
      let dimension = getImageWidthHeight (input_line data) in print_endline ("" ^ string_of_int(fst dimension) ^ " " ^ string_of_int(snd dimension));
      let pixels = Array.init (snd dimension) (fun x -> Array.make (fst dimension) 0) in
        (makeImage (charlist_of_string (lireImagelignes data)) 0 pixels)
    ;;

    let loadImage path =
      let im = getImage path in
      {image = Graphics.make_image (im); width = Array.length (Array.get im 0); height = Array.length im}
    ;;

    let rec setAr ar i c nb =
      (Array.set ar i c);
      if nb = 1 then ar else setAr ar (i+1) c (nb-1)
    ;;

    let resize im pxIN =
      fst (Array.fold_left (fun acc c -> let i = snd acc in
                                         let xligne = fst( Array.fold_left (fun acc_ c_ -> let i = snd acc_ in
                                                                                            (setAr (fst acc_) (i*pxIN) c_ pxIN, i+1)
                                                                             ) ((Array.make ((Array.length (Array.get im 0))*pxIN) 0), 0) c) in
                                         (setAr (fst acc) (i*pxIN) xligne pxIN, i+1)
                             ) ((Array.init ((Array.length im)*pxIN) (fun x -> Array.make ((Array.length (Array.get im 0))*pxIN) 0)), 0) im)
    ;;

    let loadImagePx path =
      let im = resize (getImage path) pxIN in
      {image = Graphics.make_image im; width = Array.length (Array.get im 0); height = Array.length im}
    ;;

    let image im x y =
      Graphics.draw_image im.image x y
    ;;
  end;;

(*
let rec draw frameCount =
  let startFrame = Graph.millis() in
  Graph.background (Graph.color 255 255 255);
  Graph.fill (Graph.color 0 0 0);
  keyPressed ();      Graphics.draw_image im.image x y

  Graph.text (string_of_int frameCount) 20 (Graph.height-20);
  Graph.text ("mousePressed : "^string_of_bool(Graphics.button_down ())) 20 (Graph.height-60);
  Graph.text ("millis() : "^string_of_float(Graph.millis ())) 20 (Graph.height-80);
  Graph.fill (if frameCGraphount mod 3 = 0 then (Graph.color 255 0 0)
              else if frameCount mod 3 = 1 then (Graph.color 0 255 0)
              else (Graph.color 0 0 255));
  Graph.rect 0 0 100 100;
  Graphics.synchronize ();
  Graph.wait (startFrame);
  draw (frameCount+1);
;;*)

let key = ref '_';;

Graph.setup();;
let im = Graph.loadImagePx ("./data/TokenEnd.im");;
let imN = Graph.loadImage ("./data/TokenEnd.im");;
(*print_endline (string_of_int(im.width) ^ " " ^ string_of_int(im.height));;*)
(*)
let exit () =
  Graph.exit()
;;*)

let screen1 () =
  let choiceScr = ref 1 in
  Graph.background (Graph.color 0 0 0);
  if Graphics.key_pressed () then
    (match Graphics.read_key () with
    | _ -> ()
    )
  ;
  Graph.fill(Graph.color 255 255 255);
  Graph.rect (Graph.width-20) (Graph.height-20) (20) (20);
  if !Graph.mousePressed then
    if !Graph.mouseX >= (Graph.width-20) && !Graph.mouseX <= Graph.width && !Graph.mouseY >= (Graph.height-20) && !Graph.mouseY <= Graph.height then choiceScr := -1;
  !choiceScr
;;

let screen0 () =
  let choiceScr = ref 0 in
  Graph.background (Graph.color 255 255 255);
  Graph.fill (Graph.color 0 0 0);
  Graph.text (string_of_int !Graph.frameCount) 20 (Graph.height-40);
  Graph.image imN 0 90;
  Graph.image im (int_of_float(((float_of_int(int_of_float(Graph.millis()) mod 6000)/.6000.)*.float_of_int(Graph.width-im.width)))) 0;
  if Graphics.key_pressed () then
    (match Graphics.read_key () with
    | x -> key := x;
    | _ -> ()
    )
  ;
  Graph.rect (Graph.width-20) (Graph.height-20) (20) (20);
  Graph.text (String.make 1 !key) 20 (Graph.height-70);
  if !Graph.mousePressed then
    if !Graph.mouseX >= (Graph.width-20) && !Graph.mouseX <= Graph.width && !Graph.mouseY >= (Graph.height-20) && !Graph.mouseY <= Graph.height then choiceScr := 1;
  !choiceScr
;;

let screenList = [screen0; screen1];;
(*
Screen Format :

(fun () ->
      Graph.background (Graph.color 255 255 255);
      if Graphics.key_pressed () then
        (match Graphics.read_key () with
        | _ -> ()
        )
      ;
      if Graphics.button_down () then
        ()
      ;
)

*)