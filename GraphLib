#load "graphics.cma";;
#load "unix.cma";;
type ocImage = {image : Graphics.image; width : int; height : int};;

module Graph :
  sig

    val width : int
    val height : int
    val frameRate : float
    val millis : unit -> float

    val wait : float -> unit

    val nameWindow : string

    val frameCount : int ref
    val mouseX : int ref
    val mouseY : int ref
    val startFrame : float ref

    val beginDraw : unit -> unit
    val endDraw : unit -> unit
    val draw : (unit -> unit) -> unit

    val size : int -> int -> unit

    val exit : unit -> unit

    val color : int -> int -> int -> Graphics.color

    val fill : Graphics.color -> unit

    val rect : int -> int -> int -> int -> unit

    val background : Graphics.color -> unit

    val ellipse : int -> int -> int -> int -> unit

    val set : int -> int -> unit

    val line : int -> int -> int -> int -> unit

    val strokeWeight : int -> unit

    val text : string -> int -> int -> unit

    val wait : float -> unit

    val loadImage : string -> ocImage

    val image : ocImage -> int -> int -> unit

  end =
  struct

    let width = 800;;
    let height = 600;;
    let nameWindow = "MasterMind";;
    let frameRate = 60.;; (* fps *)

    let startMillisCount = Unix.gettimeofday();;
    let millis () = (Unix.gettimeofday()-.startMillisCount)*.1000.;;width
    let waitValue = 1000./.frameRate;;

    let frameCount = ref 0;;
    let mouseX = ref 0;;
    let mouseY = ref 0;;
    let startFrame = ref 0.;;

    let rec wait start =
      (*print_endline ((string_of_float (Unix.gettimeofday())) ^ " " ^ string_of_float(start));*)
      if millis()-.start < waitValue then wait start
    ;;

    let beginDraw () =
      let mouseCoord = Graphics.mouse_pos () in
      mouseX := fst (mouseCoord);
      mouseY := snd (mouseCoord);
      frameCount := !frameCount+1;
      startFrame := millis()
    ;;

    let endDraw () =
      Graphics.synchronize ();
      wait (!startFrame);
    ;;

    let rec draw proc =
      beginDraw();
      proc ();
      endDraw();
      draw proc;
    ;;

    let size x y =
      Graphics.open_graph (" " ^ (string_of_int x)^"x"^(string_of_int y));
      Graphics.set_window_title nameWindow;
      Graphics.set_font "-*-fixed-medium-r-semicondensed--25-*-*-*-*-*-iso8859-1";
    ;;

    let exit () = Graphics.close_graph ();;

    let color r g b = Graphics.rgb r g b;;

    let fill co = Graphics.set_color (co);;

    let rect x y w h =
      Graphics.fill_rect x y w h
    ;;

    let background co =
      fill co;
      rect 0 0 width height
    ;;

    let ellipse x y w h =
      Graphics.fill_ellipse x y (w/2) (h/2)
    ;;

    let set x y =
      Graphics.plot x y
    ;;

    let line x1 y1 x2 y2 =
      Graphics.moveto x1 y1;
      Graphics.lineto x2 y2;
    ;;

    let strokeWeight x = Graphics.set_line_width x;;

    let text txt x y =
      Graphics.moveto x y;
      Graphics.draw_string txt;
    ;;

    let input_line_option ch =
      try Some(input_line ch) with
      | _ -> None
    ;;

    let rec lireImagelignes_rec ch l =
      let k = input_line_option ch in
      match k with
      | Some(s) -> lireImagelignes_rec ch (l ^ s)
      | None -> close_in ch; l
    ;;

    let lireImagelignes data =
      lireImagelignes_rec data ""
    ;;

    let rec charlist_of_string_rec s i l =
      if i >= 0 then charlist_of_string_rec s (i-1) (String.get s i::l)
      else l
    ;;

    let charlist_of_string s =
      charlist_of_string_rec s ((String.length s)-1) []
    ;;

    let getImageWidthHeight x =
      let out = fst (List.fold_left (fun acc c -> let data = fst acc in
                                            let mode = snd acc in
                                            if mode then
                                              let out = (String.make 1 c) in (((fst data), (snd data) ^ out), mode)
                                            else
                                              let out = (String.make 1 c) in
                                              if String.compare out "|" = 0 then (data, true)
                                              else (((fst data)^out, snd data), mode)
                                    ) (("",""), false) (charlist_of_string x)) in (int_of_string (fst out), int_of_string (snd out))
    ;;

    let stringArrayInt a =
      (Array.fold_left (fun acc c -> acc ^ (string_of_int c)^" ") "[|" a) ^ "|]"
    ;;

    let stringArrayArrayInt a =
      (Array.fold_left (fun acc c -> acc ^ (stringArrayInt c)^ "\n ") "[|" a) ^ "|]"
    ;;

    let rec makeImage s i a =
      if i = Array.length (a)*Array.length (Array.get a 0) then a
      else
        match s with
        | alpha::r::g::b::l -> (*print_endline ((string_of_int i) ^ " " ^ string_of_int(int_of_char r) ^ " " ^ string_of_int(int_of_char g) ^ " " ^ string_of_int(int_of_char b) ^ " " ^ string_of_int(int_of_char alpha))(* ^ " \n" ^ (stringArrayArrayInt a))*);*)
                        Array.set (Array.get a (i/(Array.length (Array.get a 0)))) (i mod (Array.length (Array.get a 0))) (if (int_of_char alpha <> 0) then (Graphics.rgb (int_of_char r) (int_of_char g) (int_of_char b))
                                                                                                                           else Graphics.transp);
                        makeImage l (i+1) a
        | _ -> (*print_endline (stringArrayArrayInt a );*) a
    ;;

    let loadImage path =
      let data = open_in (path) in
      let dimension = getImageWidthHeight (input_line data) in print_endline ("" ^ string_of_int(fst dimension) ^ " " ^ string_of_int(snd dimension));
      let pixels = Array.init (snd dimension) (fun x -> Array.make (fst dimension) 0) in
      {image = Graphics.make_image (makeImage (charlist_of_string (lireImagelignes data)) 0 pixels); width = (fst dimension); height = (snd dimension)}
    ;;

    let image im x y =
      Graphics.draw_image im.image x y
    ;;
  end;;

let keyPressed () =
  if Graphics.key_pressed () then
    let key = Graphics.read_key () in
      Graph.text ("keyPressed : "^string_of_bool(true)^ " " ^ (String.make 1 key)) 20 (Graph.height-40);
  else
    Graph.text ("keyPressed : "^string_of_bool(false)) 20 (Graph.height-40);
;;

let setup () =
  Graph.size Graph.width Graph.height;
  Graphics.auto_synchronize false;
;;

(*
let rec draw frameCount =
  let startFrame = Graph.millis() in
  Graph.background (Graph.color 255 255 255);
  Graph.fill (Graph.color 0 0 0);
  keyPressed ();      Graphics.draw_image im.image x y

  Graph.text (string_of_int frameCount) 20 (Graph.height-20);
  Graph.text ("mousePressed : "^string_of_bool(Graphics.button_down ())) 20 (Graph.height-60);
  Graph.text ("millis() : "^string_of_float(Graph.millis ())) 20 (Graph.height-80);
  Graph.fill (if frameCGraphount mod 3 = 0 then (Graph.color 255 0 0)
              else if frameCount mod 3 = 1 then (Graph.color 0 255 0)
              else (Graph.color 0 0 255));
  Graph.rect 0 0 100 100;
  Graphics.synchronize ();
  Graph.wait (startFrame);
  draw (frameCount+1);
;;*)

let key = ref '_';;

setup();;
let im = Graph.loadImage ("./google.im");;
print_endline (string_of_int(im.width) ^ " " ^ string_of_int(im.height));;

let screen1 =
(fun () ->
      Graph.background (Graph.color 255 255 255);
      Graph.fill (Graph.color 0 0 0);
      Graph.text (string_of_int !Graph.frameCount) 20 (Graph.height-40);
      Graph.image im (int_of_float(((float_of_int(int_of_float(Graph.millis()) mod 6000)/.6000.)*.float_of_int(Graph.width-im.width)))) 0;
      if Graphics.key_pressed () then
        (match Graphics.read_key () with
        | x -> key := x;
        | _ -> ()
        )
      ;
      Graph.rect (Graph.width-20) (Graph.height-20) (20) (20);
      Graph.text (String.make 1 !key) 20 (Graph.height-70);
      if Graphics.button_down () then
        if !Graph.mouseX >= (Graph.width-20) && !Graph.mouseX <= Graph.width && !Graph.mouseY >= (Graph.height-20) && !Graph.mouseY <= Graph.height then
          exit();
        Graph.rect (!Graph.mouseX-10) (!Graph.mouseY-10) 20 20
      ;
);;
(*
Screen Format :

(fun () ->
      Graph.background (Graph.color 255 255 255);
      if Graphics.key_pressed () then
        (match Graphics.read_key () with
        | _ -> ()
        )
      ;
      if Graphics.button_down () then
        ()
      ;
)

*)

let exit () =
  Graph.exit()
;;